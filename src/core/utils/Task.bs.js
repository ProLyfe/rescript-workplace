// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "@rescript/std/lib/es6/curry.js";
import * as Belt_List from "@rescript/std/lib/es6/belt_List.js";
import * as Belt_Option from "@rescript/std/lib/es6/belt_Option.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";

function from(taskLike) {
  return taskLike;
}

function make(computation, cb) {
  var cancelled = {
    contents: false
  };
  Curry._1(computation, (function (res) {
          if (!cancelled.contents) {
            return Curry._1(cb, res);
          }
          
        }));
  return function (param) {
    cancelled.contents = true;
    
  };
}

function pure(value, cb) {
  Curry._1(cb, value);
  return function (param) {
    
  };
}

function fork(f, x) {
  return Curry._1(f, x);
}

function map(task, f, cb) {
  return Curry._1(task, (function (a) {
                return Curry._1(cb, Curry._1(f, a));
              }));
}

function call(f) {
  return Curry._1(f, undefined);
}

function tap(task, onFork, f, cb) {
  Belt_Option.forEach(onFork, call);
  return Curry._1(task, (function (v) {
                Curry._1(f, v);
                return Curry._1(cb, v);
              }));
}

function flatMap(task, f, cb) {
  var cancels = {
    contents: /* [] */0
  };
  cancels.contents = {
    hd: Curry._1(task, (function (a) {
            cancels.contents = {
              hd: Curry._2(f, a, cb),
              tl: cancels.contents
            };
            
          })),
    tl: /* [] */0
  };
  return function (param) {
    return Belt_List.forEach(cancels.contents, call);
  };
}

function product(task1, task2, cb) {
  var a = {
    contents: undefined
  };
  var b = {
    contents: undefined
  };
  var cb$p = function (r, v) {
    r.contents = Caml_option.some(v);
    var match = a.contents;
    var match$1 = b.contents;
    if (match !== undefined && match$1 !== undefined) {
      return Curry._1(cb, [
                  Caml_option.valFromOption(match),
                  Caml_option.valFromOption(match$1)
                ]);
    }
    
  };
  var cancels_0 = Curry._1(task1, (function (param) {
          return cb$p(a, param);
        }));
  var cancels_1 = {
    hd: Curry._1(task2, (function (param) {
            return cb$p(b, param);
          })),
    tl: /* [] */0
  };
  var cancels = {
    hd: cancels_0,
    tl: cancels_1
  };
  return function (param) {
    return Belt_List.forEach(cancels, call);
  };
}

function map2(task1, task2, f) {
  return function (param) {
    var f$1 = function (param) {
      return Curry._2(f, param[0], param[1]);
    };
    return product(task1, task2, (function (a) {
                  return Curry._1(param, Curry._1(f$1, a));
                }));
  };
}

export {
  from ,
  make ,
  pure ,
  fork ,
  map ,
  tap ,
  flatMap ,
  product ,
  map2 ,
  
}
/* No side effect */
